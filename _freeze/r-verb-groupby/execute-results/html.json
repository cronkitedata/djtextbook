{
  "hash": "324ab3d05c2a48bdfb08a6de43e3ebda",
  "result": {
    "markdown": "---\nexecute: \n  message: false\n---\n\n\n# Verbs in depth: Aggregating with groups {#r-verb-groupby}\n\n\n\n\n\n::: callout-warning\n## Editor's note\n\nI have tried and tried to write this chapter so it makes sense. I can't do it. Think of it instead as three mini-chapters. You might want to skip the third section for now and come back to it when you are more comfortable.\n\n-   [Section 1](#summarize-and-group_by-basics): Basic counting and summing with `group_by` and `summarize`\n-   [Section 2](#using-and-converting-groups): Using and converting groups into spreadsheet (wide) format and percentages.\n-   [Section 3](#understanding-grouped-data): Understanding tidy data and how it makes grouping so powerful. You'll find that things you expect to do for \"wide\" data is more efficiently done with groups. It's counterintuitive.\n:::\n\n::: {.alert .alert-secondary}\n::: {.alert-heading .font-weight-bolder .fs-3}\nIn this chapter:\n:::\n\n-   `group_by` and `summarize` are the tidyverse's version of Excel pivot tables, with many more possibilities.\n-   R is picky and will create different rows for the tiniest difference between values, such as \"Lettuce\" vs. \"lettuce\".\n-   `group_by` and `summarize` often go together. [^r-verb-groupby-1]\n-   You will often have to accommodate missing data, or the dreaded \"NA\" values.\n-   Compute percent of total using grouped data\n-   Go from \"long\" database format to \"wide\" spreadsheet format and back using `pivot_` functions.\n-   An easy shortcut: `count()`\n-   Understanding grouped data as a \"tidy\" data structure with magical powers\n:::\n\n[^r-verb-groupby-1]: Beginning in February 2023, there is a new version of `summarize` that eliminates the need to group the data first. We're not using that version, and I don't want to confuse you, so I'm ignoring it. Future versions of this chapter will *try* to explain it.\n\nThis chapter continues with the Paycheck Protection Program, or PPP, loans in Arizona. Full documentation of the dataset is in the [Appendix](appendix-ppp.html). If you haven't already, look through that documentation before you start.\n\n::: {.alert-success .alert-dothis}\nAs you have in the last several chapters, open your R project and create a new Quarto document with the [front matter and libraries](https://gist.github.com/sarahcnyt/e60ad2d7ccf65498fc88791f3bb683ae).\n\nThen load the saved PPP data with this code chunk:\n:::\n\n\n::: {.cell}\n\n```{.r .cell-code}\nppp_orig <- readRDS (\n               url ( \n                 \"https://cronkitedata.s3.amazonaws.com/rdata/ppp_az_loans.RDS\"\n                 )\n               )\n```\n:::\n\n\n## `summarize` and `group_by` basics {#summarize-and-group_by-basics}\n\n### `summarize`\n\n`summarize`[^r-verb-groupby-2] computes summary statistics such as the number of rows in a data frame or the sum of dollar values. It removes the original columns completely, and only produces the summary statistics you compute within that statement. **Using `summarize` alone produces a data frame with one row.** It's the equivalent of putting nothing in your pivot table in Excel other than the \"Values\" area.\n\n[^r-verb-groupby-2]: A synonym for the British spelling `summarise`, which you'll see in a lot of examples\n\nAnother way to think of `summarize` is that it collapses your list of items (loans, in our example) into a statistical report.\n\n#### The dreaded `NA`\n\nYou saw in the `mutate` section that missing values are always a problem. Because they're unknown, they can't match anything else, they can't be considered 0, and they can warp any answers you get. But there's usually nothing you can do about missing data, so you have to tell the program exactly what to do about them.\n\nThere are two choices:\n\n-   Let them infect everything they touch, turning everything into `NA`. In this scenario, a total of the dollar values in a column would be NA if **any** of the values in that column is missing:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nppp_orig |> \n  summarize ( sum(forgiveness_amount))\n```\n\n::: {.cell-output-display}\n`````{=html}\n<div data-pagedtable=\"false\">\n  <script data-pagedtable-source type=\"application/json\">\n{\"columns\":[{\"label\":[\"sum(forgiveness_amount)\"],\"name\":[1],\"type\":[\"dbl\"],\"align\":[\"right\"]}],\"data\":[{\"1\":\"NA\"}],\"options\":{\"columns\":{\"min\":{},\"max\":[10]},\"rows\":{\"min\":[10],\"max\":[10]},\"pages\":{}}}\n  </script>\n</div>\n`````\n:::\n:::\n\n\n-   Ignore them in a computation completely, effectively removing that value from your calculation. Be careful with this - it means that two summary statistics (say,`n()` and `sum()`) could be using a different set of rows!\n\nThere's no right answer, and it depends on what you're doing. In some cases, you know that they stand for the value `0`, and in others you don't. We will usually ignore them by adding an *argument* to every summary function that could be infected by them : `na.rm = TRUE` , which means, \"remove NA's before you do anything.\".\n\n### Summary functions\n\nSome of the common functions you'll use to summarize are :\n\n-   `mean (column_name, na.rm=T)` -- for an average : Numbers only\n-   `sum (column_name, na.rm = T)`: Numbers only\n-   `n()` -- for \"how many\", or \"count\". Anything - this counts rows, not values\n-   `n_distinct ( column_name)` : The number of unique entries in the column. Use it to see how many categories there are in a column.\n-   `median (column_name, na.rm=T)`: Numbers only\n-   `min (column_name, na.rm=T)`: Dates and numbers\n-   `max (column_name , na.rm=T)`: Dates and numbers\n\nWhen used on the whole data frame, it's customary to just glimpse the output, since there's only one row:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nppp_orig |> \n  summarize ( n(), \n              mean (amount, na.rm=T), \n              mean (forgiveness_amount, na.rm=T), \n              min (date_approved, na.rm=T), \n              max (date_approved, na.rm= T), \n              n_distinct ( business_type)\n  ) |>\n  glimpse()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRows: 1\nColumns: 6\n$ `n()`                                 <int> 169259\n$ `mean(amount, na.rm = T)`             <dbl> 73206.66\n$ `mean(forgiveness_amount, na.rm = T)` <dbl> 77050.41\n$ `min(date_approved, na.rm = T)`       <date> 2020-04-03\n$ `max(date_approved, na.rm = T)`       <date> 2021-06-29\n$ `n_distinct(business_type)`           <int> 24\n```\n:::\n:::\n\n\nThis produced a data frame with 1 row and 5 columns. The column names are the same as the formulas that created them, which is difficult to work with. Create new column names using the name (in back-ticks if it's got spaces or special characters) and assign them the values of the summaries using the `=` sign:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nppp_orig |> \n  summarize ( number_of_rows =  n(), \n              mean_amount = mean (amount, na.rm=T),    \n              median_amount = median (amount, na.rm=T),\n              mean_forgiven = mean (forgiveness_amount, na.rm=T),   # doesn't count the missing as zero!\n              first_loan = min (date_approved, na.rm=T),   \n              last_loan = max (date_approved, na.rm= T), \n              business_type_count = n_distinct(business_type)\n  ) |>\n  glimpse()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRows: 1\nColumns: 7\n$ number_of_rows      <int> 169259\n$ mean_amount         <dbl> 73206.66\n$ median_amount       <dbl> 20800\n$ mean_forgiven       <dbl> 77050.41\n$ first_loan          <date> 2020-04-03\n$ last_loan           <date> 2021-06-29\n$ business_type_count <int> 24\n```\n:::\n:::\n\n\n### Grouping\n\nNow that you know how to summarize the whole data frame, you'll want to start getting totals by category. This is the same thing as a pivot table -- the column names that create the \"groups\" are the equivalent of the Rows area a spreadsheet pivot table:\n\n![](assets/images/r-verb-group-pivotcompare.png){width=\"100%\"}\n\n#### Grouping by one column\n\nIn the PPP data, the \"draw\" refers to which of the two programs was involved - the original one, or the one passed by Congress in late 2020.\n\nHere's how we'd get some key statistics by draw:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nppp_orig |>\n  group_by ( draw ) |>\n  summarize ( first_loan = min ( date_approved ), \n              total_amount = sum (amount), \n              total_forgiven = sum (forgiveness_amount, na.rm=T), \n              `# of loans` = n() \n  )\n```\n\n::: {.cell-output-display}\n`````{=html}\n<div data-pagedtable=\"false\">\n  <script data-pagedtable-source type=\"application/json\">\n{\"columns\":[{\"label\":[\"draw\"],\"name\":[1],\"type\":[\"chr\"],\"align\":[\"left\"]},{\"label\":[\"first_loan\"],\"name\":[2],\"type\":[\"date\"],\"align\":[\"right\"]},{\"label\":[\"total_amount\"],\"name\":[3],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"total_forgiven\"],\"name\":[4],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"# of loans\"],\"name\":[5],\"type\":[\"int\"],\"align\":[\"right\"]}],\"data\":[{\"1\":\"First\",\"2\":\"2020-04-03\",\"3\":\"9465606369\",\"4\":\"8972228355\",\"5\":\"128715\"},{\"1\":\"Second\",\"2\":\"2021-01-14\",\"3\":\"2925279615\",\"4\":\"2779422635\",\"5\":\"40544\"}],\"options\":{\"columns\":{\"min\":{},\"max\":[10]},\"rows\":{\"min\":[10],\"max\":[10]},\"pages\":{}}}\n  </script>\n</div>\n`````\n:::\n:::\n\n\nHere are a couple of things to note about grouped output:\n\n-   The only columns saved are the ones that are shown in either the `group_by` or `summarize` rows. All of the other original columns have been eliminated. You no longer have them to work with .\\\n-   The names of the columns for the summary statistics are the ones defined before the \"=\" sign in the summarize statement.\n-   TRAP! Don't ever name your summary columns the same thing as a group_by column. It will override those names, and your output will be unintelligible.\n\n::: callout-warning\n## Naming your columns\n\nNote that the name of the columns doesn't always follow our standard. In this case, `# of loans` has a special character and spaces. In order to create or use it, you must enclose them in back-tics (\\`) or you'll get an error.\n:::\n\n::: callout-tip\n## Expand your table to a new window\n\n::: grid\n::: {.g-col-4 .pt-2}\nIf you're using visual mode, the table that gets produced can be really squished. To see more of it, pop it out into its own window using the leftmost button. [^r-verb-groupby-3]\n:::\n\n::: {.g-col-8 .d-flex .justify-content-end .mx-4}\n![](assets/images/r-groupby-squished.png){width=\"100%\"}\n:::\n:::\n:::\n\n[^r-verb-groupby-3]: This only works if you have `df-print: paged` in your front matter (YAML between three dashes at the top\n\n#### Grouping by more than one column\n\nIf you wanted to know the numbers outstanding and forgiven by draw, you could add another column to the group by:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nppp_orig |>\n  group_by ( loan_status, draw ) |>\n  summarize ( first_loan = min ( date_approved ), \n              total_amount = sum (amount), \n              total_forgiven = sum (forgiveness_amount, na.rm=T), \n              loan_ct = n() \n  )\n```\n\n::: {.cell-output-display}\n`````{=html}\n<div data-pagedtable=\"false\">\n  <script data-pagedtable-source type=\"application/json\">\n{\"columns\":[{\"label\":[\"loan_status\"],\"name\":[1],\"type\":[\"chr\"],\"align\":[\"left\"]},{\"label\":[\"draw\"],\"name\":[2],\"type\":[\"chr\"],\"align\":[\"left\"]},{\"label\":[\"first_loan\"],\"name\":[3],\"type\":[\"date\"],\"align\":[\"right\"]},{\"label\":[\"total_amount\"],\"name\":[4],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"total_forgiven\"],\"name\":[5],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"loan_ct\"],\"name\":[6],\"type\":[\"int\"],\"align\":[\"right\"]}],\"data\":[{\"1\":\"Active Un-Disbursed\",\"2\":\"First\",\"3\":\"2021-02-23\",\"4\":\"61053\",\"5\":\"0\",\"6\":\"3\"},{\"1\":\"Exemption 4\",\"2\":\"First\",\"3\":\"2020-04-03\",\"4\":\"488322977\",\"5\":\"109392926\",\"6\":\"13573\"},{\"1\":\"Exemption 4\",\"2\":\"Second\",\"3\":\"2021-01-16\",\"4\":\"212558139\",\"5\":\"54122380\",\"6\":\"3898\"},{\"1\":\"Paid in Full\",\"2\":\"First\",\"3\":\"2020-04-03\",\"4\":\"8977222339\",\"5\":\"8862835430\",\"6\":\"115139\"},{\"1\":\"Paid in Full\",\"2\":\"Second\",\"3\":\"2021-01-14\",\"4\":\"2712721476\",\"5\":\"2725300255\",\"6\":\"36646\"}],\"options\":{\"columns\":{\"min\":{},\"max\":[10]},\"rows\":{\"min\":[10],\"max\":[10]},\"pages\":{}}}\n  </script>\n</div>\n`````\n:::\n:::\n\n\nThe `summarize` verb here has created a data frame that has only the variables you identified in the `group_by` and `summarize` commands - everything else has been removed, since it's a *summary* of your data.\n\n### A shortcut : `count()`\n\nIf all you want to do is count or add by group, you can use the `count()` function as a shortcut. It does the exact same thing as a combination of `group_by()` and `summarize( n() )` and `arrange()`\\` to get the number of items in each category, sorted by the most frequent to least:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nppp_orig |> \n  count ( loan_status, draw, \n          sort=TRUE,\n          name = \"loans\")\n```\n\n::: {.cell-output-display}\n`````{=html}\n<div data-pagedtable=\"false\">\n  <script data-pagedtable-source type=\"application/json\">\n{\"columns\":[{\"label\":[\"loan_status\"],\"name\":[1],\"type\":[\"chr\"],\"align\":[\"left\"]},{\"label\":[\"draw\"],\"name\":[2],\"type\":[\"chr\"],\"align\":[\"left\"]},{\"label\":[\"loans\"],\"name\":[3],\"type\":[\"int\"],\"align\":[\"right\"]}],\"data\":[{\"1\":\"Paid in Full\",\"2\":\"First\",\"3\":\"115139\"},{\"1\":\"Paid in Full\",\"2\":\"Second\",\"3\":\"36646\"},{\"1\":\"Exemption 4\",\"2\":\"First\",\"3\":\"13573\"},{\"1\":\"Exemption 4\",\"2\":\"Second\",\"3\":\"3898\"},{\"1\":\"Active Un-Disbursed\",\"2\":\"First\",\"3\":\"3\"}],\"options\":{\"columns\":{\"min\":{},\"max\":[10]},\"rows\":{\"min\":[10],\"max\":[10]},\"pages\":{}}}\n  </script>\n</div>\n`````\n:::\n:::\n\n\n## Using and converting groups {#using-and-converting-groups}\n\n### Converting from long to wide data\n\nTypically, if you want to just look at your data, you'd want to see one of the columns down the side (rows in pivot tables), and another across the top (columns in pivot tables). Helpfully, a new verb called `pivot_wider()` does just that -- pivots your data from long to wide.\n\nStart with a simple query with two grouping columns (note that I've called the number of loans `loan_ct`, so it's easier to work with later on.\n\n\n::: {.cell layout-ncol=\"2\"}\n::: {.cell-output-display}\n`````{=html}\n<div data-pagedtable=\"false\">\n  <script data-pagedtable-source type=\"application/json\">\n{\"columns\":[{\"label\":[\"loan_status\"],\"name\":[1],\"type\":[\"chr\"],\"align\":[\"left\"]},{\"label\":[\"draw\"],\"name\":[2],\"type\":[\"chr\"],\"align\":[\"left\"]},{\"label\":[\"loan_ct\"],\"name\":[3],\"type\":[\"int\"],\"align\":[\"right\"]}],\"data\":[{\"1\":\"Active Un-Disbursed\",\"2\":\"First\",\"3\":\"3\"},{\"1\":\"Exemption 4\",\"2\":\"First\",\"3\":\"13573\"},{\"1\":\"Exemption 4\",\"2\":\"Second\",\"3\":\"3898\"},{\"1\":\"Paid in Full\",\"2\":\"First\",\"3\":\"115139\"},{\"1\":\"Paid in Full\",\"2\":\"Second\",\"3\":\"36646\"}],\"options\":{\"columns\":{\"min\":{},\"max\":[10]},\"rows\":{\"min\":[10],\"max\":[10]},\"pages\":{}}}\n  </script>\n</div>\n`````\n:::\n:::\n\n\nThis is really hard to read. Turn it on its head with `pivot_wider()`:\n\n![](assets/images/r-groupby-pivotwider.png)\n\nNormally, you'll only want to have one summary statistic shown in a rectangle, with one column spread across the top and another column shown in rows. In R, this is done by \"pivoting\" your tables. There are a lot of advanced options in pivot functions that let you show more than one statistic at a time, and tell R how to name them. There will be a chapter later on that addresses a lot of the problems you have in reading tables, so we'll put that off for now.\n\nHere's an explanation of what the command looks like.\n\n\n::: {.cell}\n\n```{.markdown .cell-code}\n\npivot_wider ( id_cols = *list of columns to keep down the side* , \n                names_from = *the name of the column supplying the headings across the top*, \n                values_from = *the values you want to show in each cell* , \n                values_fill = *what you want to show if it's empty, usually 0 *\n                )\n```\n:::\n\n\n::: callout-tip\nYour instinct will often be that you want to see your data in this form, but you can and should actually do most of your work without it. This is a core concept of the tidyverse, which is detailed in this chapter's last section. But even if you don't look at that part, remember that pivoting to a \"wide\" format is usually your last step, not one of your first.\n:::\n\n### Totals and subtotals\n\nYou noticed that when you created the summaries, there was no option to create a \"percent of total\" such as the percent of loans in each draw, or the percent of money that had been forgiven.\n\nYou can use summary functions outside a summarize statement! This means that you can compute the percent of total, the same way you used an option in pivot tables. This took me a long time to understand, so try to slow down, and just try it a few times! When you look carefully at your output, you'll start to understand it better.\n\nThe trick is to summarize, then use `mutate` to add a column with the percentages made out of totals:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nppp_orig |>\n  group_by ( draw) |>\n  summarize ( loan_count = n() ) |>\n  mutate ( all_loans = sum (loan_count), \n           pct_of_total = loan_count / all_loans * 100\n           )\n```\n\n::: {.cell-output-display}\n`````{=html}\n<div data-pagedtable=\"false\">\n  <script data-pagedtable-source type=\"application/json\">\n{\"columns\":[{\"label\":[\"draw\"],\"name\":[1],\"type\":[\"chr\"],\"align\":[\"left\"]},{\"label\":[\"loan_count\"],\"name\":[2],\"type\":[\"int\"],\"align\":[\"right\"]},{\"label\":[\"all_loans\"],\"name\":[3],\"type\":[\"int\"],\"align\":[\"right\"]},{\"label\":[\"pct_of_total\"],\"name\":[4],\"type\":[\"dbl\"],\"align\":[\"right\"]}],\"data\":[{\"1\":\"First\",\"2\":\"128715\",\"3\":\"169259\",\"4\":\"76.04618\"},{\"1\":\"Second\",\"2\":\"40544\",\"3\":\"169259\",\"4\":\"23.95382\"}],\"options\":{\"columns\":{\"min\":{},\"max\":[10]},\"rows\":{\"min\":[10],\"max\":[10]},\"pages\":{}}}\n  </script>\n</div>\n`````\n:::\n:::\n\n\n#### What happens if you have more than one group?\n\nThis is where the idea of grouped data gets a little confusing. It depends on exactly how you did your summarize statement. But if you use the default mechanism, the \"all_loans\" is the subtotal. The default behavior is that the \"groups\" are kept for all but the last column listed in the group_by statement, meaning any summaries you do off of the data will refer to the subtotal. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nppp_orig |>\n  group_by ( draw, loan_status) |>\n  summarize ( loan_count = n() ) |>\n  mutate ( loans_in_draw = sum (loan_count),\n           pct_of_draw = loan_count / loans_in_draw * 100)\n```\n\n::: {.cell-output-display}\n`````{=html}\n<div data-pagedtable=\"false\">\n  <script data-pagedtable-source type=\"application/json\">\n{\"columns\":[{\"label\":[\"draw\"],\"name\":[1],\"type\":[\"chr\"],\"align\":[\"left\"]},{\"label\":[\"loan_status\"],\"name\":[2],\"type\":[\"chr\"],\"align\":[\"left\"]},{\"label\":[\"loan_count\"],\"name\":[3],\"type\":[\"int\"],\"align\":[\"right\"]},{\"label\":[\"loans_in_draw\"],\"name\":[4],\"type\":[\"int\"],\"align\":[\"right\"]},{\"label\":[\"pct_of_draw\"],\"name\":[5],\"type\":[\"dbl\"],\"align\":[\"right\"]}],\"data\":[{\"1\":\"First\",\"2\":\"Active Un-Disbursed\",\"3\":\"3\",\"4\":\"128715\",\"5\":\"0.002330731\"},{\"1\":\"First\",\"2\":\"Exemption 4\",\"3\":\"13573\",\"4\":\"128715\",\"5\":\"10.545002525\"},{\"1\":\"First\",\"2\":\"Paid in Full\",\"3\":\"115139\",\"4\":\"128715\",\"5\":\"89.452666744\"},{\"1\":\"Second\",\"2\":\"Exemption 4\",\"3\":\"3898\",\"4\":\"40544\",\"5\":\"9.614246251\"},{\"1\":\"Second\",\"2\":\"Paid in Full\",\"3\":\"36646\",\"4\":\"40544\",\"5\":\"90.385753749\"}],\"options\":{\"columns\":{\"min\":{},\"max\":[10]},\"rows\":{\"min\":[10],\"max\":[10]},\"pages\":{}}}\n  </script>\n</div>\n`````\n:::\n:::\n\n\nHere's a pretty typical way to do this: Create a subtotal, use it for your percentages, then pivot the percentages:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nppp_orig |> \n  group_by ( draw, loan_status) |> \n  summarize ( loan_count = n() ) |> \n  mutate ( loans_in_draw = sum(loan_count), \n           pct_of_draw = loan_count / loans_in_draw * 100 ) |> \n  pivot_wider ( \n    id_cols = c(draw, loans_in_draw), \n    names_from = loan_status, \n    values_from = pct_of_draw,\n    values_fill = 0)\n```\n\n::: {.cell-output-display}\n`````{=html}\n<div data-pagedtable=\"false\">\n  <script data-pagedtable-source type=\"application/json\">\n{\"columns\":[{\"label\":[\"draw\"],\"name\":[1],\"type\":[\"chr\"],\"align\":[\"left\"]},{\"label\":[\"loans_in_draw\"],\"name\":[2],\"type\":[\"int\"],\"align\":[\"right\"]},{\"label\":[\"Active Un-Disbursed\"],\"name\":[3],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"Exemption 4\"],\"name\":[4],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"Paid in Full\"],\"name\":[5],\"type\":[\"dbl\"],\"align\":[\"right\"]}],\"data\":[{\"1\":\"First\",\"2\":\"128715\",\"3\":\"0.002330731\",\"4\":\"10.545003\",\"5\":\"89.45267\"},{\"1\":\"Second\",\"2\":\"40544\",\"3\":\"0.000000000\",\"4\":\"9.614246\",\"5\":\"90.38575\"}],\"options\":{\"columns\":{\"min\":{},\"max\":[10]},\"rows\":{\"min\":[10],\"max\":[10]},\"pages\":{}}}\n  </script>\n</div>\n`````\n:::\n:::\n\n\nNow you can easily compare the outcome by draw, by reading across to reach 100% and reading down to compare them.\n\nWe'll have a whole chapter / week on making good tables that are readable and understandable. For now, just remember that it's always possible to turn a data frame on its head, and that you can compute much of what you need BEFORE you do that.\n\n## Practice\n\nPutting together the grouping and summarizing, along with the commands you learned last chapter to `filter`, `arrange` and display the `head()` and `tail()` of a dataset should equip you to write the code for these questions:\n\n1.  Which lenders provided the most loans?\n2.  Which lenders provided the most amount of money loaned?\n3.  Which borrowers got the least amount of money?\n4.  Show the number of loans in each draw that went to the 24 (including `NA`) types of businesses. To see them all on one screen, add \", rows.print=25\" to the heading of the code chunk like this: `{r  , rows.print=25}`\n5.  Try to compute the percent of loans that went to projects in each county in Arizona. This will require first filtering, then grouping.\n\n## Understanding grouped data {#understanding-grouped-data}\n\nYou may have noticed an odd warning after you run the code with multiple grouping columns, for example:\n\n\n::: {.cell}\n\n```{.markdown .cell-code}\n\n`summarise()` has grouped output by 'loan_status'. You can override using the `.groups` argument.\" \n\n```\n:::\n\n\n#### What does that mean?\n\nWhen you grouped by loan status and draw, R effectively split up your data frame into five independent and completely divorced piles - one for each combination of draw and loan status that it found. It processed them one by one to create the output data frame that was printed out.\n\nAfter it's done summarizing your data, R doesn't know what you want to do with the piles -- keep them, or put everything back together again.\n\nBy default, after you group by more than one column, it maintains the separate piles for all but the last group in your list under `group_by` -- in this case the `loan_status`. Here, everything you do after this will work on three piles separately.The message tells you what it did with the piles, and how to change that behavior.\n\nThe [documentation of grouped data](https://dplyr.tidyverse.org/articles/grouping.html) provides details of how each of the tidyverse's verbs handle grouped data.\n\nHere's what a \"glimpse()\" looks like for a data frame that has retained some groups:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nppp_orig |> \n  select ( loan_status, date_approved:amount) |> \n  group_by ( loan_status) |> glimpse()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRows: 169,259\nColumns: 11\nGroups: loan_status [3]\n$ loan_status      <chr> \"Paid in Full\", \"Paid in Full\", \"Paid in Full\", \"Paid…\n$ date_approved    <date> 2020-04-10, 2020-04-11, 2020-04-11, 2020-04-29, 2020…\n$ draw             <chr> \"First\", \"First\", \"First\", \"First\", \"First\", \"First\",…\n$ borrower_name    <chr> \"SFE HOLDINGS LLC\", \"NAVAJO TRIBAL UTILITY AUTHORITY\"…\n$ borrower_address <chr> \"9366 East Raintree Drive\", \"Po Box 170\", \"2999 N44th…\n$ borrower_city    <chr> \"Scottsdale\", \"Fort Defiance\", \"Phoenix\", \"Tucson\", \"…\n$ borrower_state   <chr> \"AZ\", \"AZ\", \"AZ\", \"AZ\", \"AZ\", \"AZ\", \"AZ\", \"AZ\", \"AZ\",…\n$ borrower_zip     <chr> \"85260\", \"86504\", \"85018\", \"85711\", \"85250\", \"85012\",…\n$ franchise_name   <chr> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, N…\n$ loan_status_date <date> 2021-08-17, 2022-02-05, 2021-09-25, 2021-08-21, 2021…\n$ amount           <dbl> 10000000, 10000000, 10000000, 10000000, 10000000, 100…\n```\n:::\n:::\n\n\nNotice the \"Groups\" row at the top -- that tells you it's got three piles, defined by the loan_status column.\n\n#### Getting rid of the message\n\nYou can do three things to get rid of the message. I suggest the first of these, since it makes you explicitly decide what to do each time, depending on your goal:\n\n1.  Add a `.groups=...` argument that looks like this at the end of the `summarize` statement. This example tells R to do what it does by default, with no warning:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nppp_orig |>\n  group_by ( loan_status, draw ) |>\n  summarize ( `# of loans` = n() , \n              .groups = \"drop_last\"\n  )\n```\n\n::: {.cell-output-display}\n`````{=html}\n<div data-pagedtable=\"false\">\n  <script data-pagedtable-source type=\"application/json\">\n{\"columns\":[{\"label\":[\"loan_status\"],\"name\":[1],\"type\":[\"chr\"],\"align\":[\"left\"]},{\"label\":[\"draw\"],\"name\":[2],\"type\":[\"chr\"],\"align\":[\"left\"]},{\"label\":[\"# of loans\"],\"name\":[3],\"type\":[\"int\"],\"align\":[\"right\"]}],\"data\":[{\"1\":\"Active Un-Disbursed\",\"2\":\"First\",\"3\":\"3\"},{\"1\":\"Exemption 4\",\"2\":\"First\",\"3\":\"13573\"},{\"1\":\"Exemption 4\",\"2\":\"Second\",\"3\":\"3898\"},{\"1\":\"Paid in Full\",\"2\":\"First\",\"3\":\"115139\"},{\"1\":\"Paid in Full\",\"2\":\"Second\",\"3\":\"36646\"}],\"options\":{\"columns\":{\"min\":{},\"max\":[10]},\"rows\":{\"min\":[10],\"max\":[10]},\"pages\":{}}}\n  </script>\n</div>\n`````\n:::\n:::\n\n\n  The other possibilities are : `.groups=\"drop\"` and `\".groups=\"keep\"` (Note the period before the word \"groups\". I have no idea why, but sometimes options are indicated this way.)\n\n2.  Suppress all messages either for the whole document or for the code chunk. Here's what your YAML would look like if you added `message: false` to it. (This has the benefit of suppressing a lot of other annoying messages that you might not care about as well):\n\n\n::: {.cell}\n\n```{.yaml .cell-code}\n\ntitle: \"YOUR TITLE - CHANGE THIS\"\nauthor: \"YOUR NAME - CHANGE THIS\"\nformat:\n  html:\n    toc: true\n    code-tools: true\n    embed-resources: true\n    df-print: paged\n    page-layout: full\nexecute: \n  message: false\n\n```\n:::\n\n\n3.  Add a line to your setup chunk, changing the default behavior through the systemwide options:\n\n    `options(dplyr.summarise.inform = FALSE)`\n\n### Tidy data and \"long\" vs. \"wide\" use in groups\n\n::: {.blockquote .mt-3}\nLike families, tidy datasets are all alike but every messy dataset is messy in its own way.\n\n-- Hadley Wickham, with apologies to Leo Tolstoy\n:::\n\nThe concept of tidy data was outlined by Hadley Wickham in a [seminal paper](https://vita.had.co.nz/papers/tidy-data.pdf) nearly a decade ago, which defined a specific way of organizing data values within a dataset. .Wickham argues that by following the principle, you know how you would LIKE your data to be organized, and don't have to figure it out every time you encounter a new dataset. But a lot of people have trouble internalizing the concepts of tidy data. Once you do, everything else we're doing in this book makes more sense.\n\n-   Each column is a \"variable\", in that it defines a single attribute, such as height, weight, or zip code.\n-   Each row an \"observation\", which contains all values of the variables measured on the same unit (say, person)\n-   Each \"value\" (usually number, text or date) belongs to a variable and an observation -- it lies in the intersection of the two, and is seen in a cell.\n-   Each dataset, or spreadsheet, or data frame, refers to a different type of unit. There would be one for people, another for traffic tickets and a third for vehicles. These are the nouns that we've talked so much about.\n\nOur PPP data starts in tidy form, but we converted it to un-tidy data by pivoting it.\n\n#### Real world non-tidy data\n\nWickham laid out several ways that we see data when it's not tidy. The three most common are:\n\n1.  Column headings are values, not variables. When a column heading shows each year, it is showing the value of the year variable, not something separate. This happens most of the time when you obtain data that is intended for publication, not analysis.\n\n2.  Multiple variables are stored in one column. This can be taken too far, but you have to decide what the important level of detail is: Full name, or first name and last name? It can also come in data like the Census Bureau, where a value might represent both an age and a gender. (Male, 25-54 years old )\n\n3.  Rows might contain different levels of detail. This also comes from getting printouts rather than original datasets, where subtotals and totals are shown in rows, not in a separate table. We have talked about the noun represented by each row -- it should always be the same, so students and schools shouldn't be in the same table; schools and school districts should be separated.\n\n#### What does this have to do with grouped data?\n\nGrouped data effectively breaks out values of categories and treats them independently, which is the equivalent of temporarily treating them as their own column.\n\nIt's somewhat difficult in the tidyverse to summarize across columns -- it really wants to summarize rows. In a spreadsheet, it's just as easy to write an `=sum(B1:J1)` as it is `=sum(B1:B12)`. But the tidyverse is only expecting you do to the second version (rows B1:b12), not the first. The reason is that it would make no sense to sum truly different variables (like adding up income and house price)!\n\nIt means that in our R journey so far, grouped data is the first place you would have encountered situations in which your instinct is to wreck a perfectly good dataset.\n\nWe'll come back to all of that, but just remember that it's possible to do all kinds of computations within a group that you'd normally think you want to do across columns. One example is, say, the change in COVID cases by county. Computing monthly percent changes would look something like this using the `lag()` function to get the previous row. This assumes the \"tidy\" data looks something like this:\n\n| state | county | month      | cases |\n|-------|--------|------------|-------|\n| AL    | Auburn | 2020-04-01 | 24    |\n| AL    | Auburn | 2020-05-01 | 35    |\n| AL    | Auburn | 2020-06-01 | 200   |\n\n    covid_data |>\n      group_by (state, county) |> \n      arrange (month) |> \n      mutate ( change = cases - lag(cases) , \n               pct_change = change / lag(cases) * 100 ) \n\nThis method will start over for each county, so it will be `NA` for the first month within each county.\n\n(Your instinct may have been to pivot the data to show each month in its own column, then compute the percent change on each of those columns -- something that could get really old really quickly. )\n\nThis is just one example of how grouped data is quite powerful when used correctly. There are many others, such as extracting the most recent event in a court history by case. Try to think about how one group would be computed, and then don't worry how the rest will work -- R will do that thinking for you. \n\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<link href=\"site_libs/pagedtable-1.1/css/pagedtable.css\" rel=\"stylesheet\" />\n<script src=\"site_libs/pagedtable-1.1/js/pagedtable.js\"></script>\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}