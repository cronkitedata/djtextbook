{
  "hash": "a0787d940b3102a144b533b97cfd75f9",
  "result": {
    "markdown": "---\nexecute: \n   echo: true\n   output: false\n   error: true\n   eval: false\noutput: \n   html: \n      number-depth: 2\n--- \n\n\n# Recipes {#r-recipes}\n\n\n\n\n\n\n\n\nThis final chapter on data wrangling in R simply puts together a lot of the code snippets that are easy to forget, and adds some more advanced code examples that you can adapt to your work. There is minimal explanation. Instead, look at at the relevant chapter for more explanation. Over time, I'll add section links to the examples.\n\nYou can copy and paste these into RStudio's snippets and use them directly in your program -- then you just have to change the references to the variables in your own work.\n\nThese examples use the data from the other chapters, from the PPP program.\n\n### R annoyances and errors {-}\n\nThere are several annoyances that aren't consistent from one function in R to the next. When you're having trouble, look for\n\n-   **Quoting issues** - what kind of quotes, whether they're needed, and if they're matched open and closed.\n\n-   Unmatched or missing **parentheses**\n\n    Putting words on the wrong side of **equal signs**. To create a new column name, put it on the left. To identify a column to be used as an argument, put it on the right. To filter a column, use two equals signs, with the column name on the left.\n\n-   Are you working with a **list** of items? If so, you need to wrap them in the `c()` function, for \"combine\"\n\n-   **Case-sensitivity** in column names; back-ticks for more than one word in a column name rather than quotes.\n\n-   Missing or hanging **pipes** (`|>`)\n\n- You often have to run your code chunk twice after fixing an error. (There is still a mistake in R's innards that has to get flushed out.)\n\nThese are the problems that will fix about 80 percent of the code that won't run once you get more used to it.\n\n## Re-using answers from a previous step\n\nAssign your code chunk to a new variable in the environment to use it again later. This is usefule when: \n\n* You have a complex filter that you want to apply to future steps. \n* You are joining data frames with columns having the same names: select just the columns you need and re-name any of the ones that are the same, except for the join one. \n* You have fixed some column types or adjusted their values. \n\nThe assignment operator is `<-`, which means \"pour the answer into this variable name\"\n\nThese can all go into one code chunk if you'd like: \n\n\n::: {.cell}\n\n```{.r .cell-code}\nselect_ppp <- \n  ppp_orig |>\n  filter ( project_state == \"AZ\" & !is.na (project_county) ) |>\n  mutate ( forgiveness_amount = if_else (is.na(forgiveness_amount),\n                                         0, \n                                         forgiveness_amount)) |>\n  select ( borrower_name, borrower_city, \n           naics_code, \n           amount, forgiveness_amount,\n           date_approved, forgiveness_date)\n\n\n\nsectors <- \n  naics_codes |>\n  select ( naics_code, sector_code, sector_desc)\n\n\nselect_ppp |>\n  left_join ( sectors, by=\"naics_code\")  |>\n  select ( borrower_name, forgiveness_amount, sector_desc) |>\n  head(5)\n```\n:::\n\n\n## Importing / reading data\n\n* If you are referring to a file on your computer or on the web, then it must be in quotes. \n* Use the proper library and function to read the data. \n* Check the output for proper treatment of text, dates and numbers, especially with Excel and text imports\n\n\n#### Reading R files\n\nTwo types of data files: RDS files contain one data frame, which you have to assign to a new object. Rda files have multiple objects that are already named.  Use `readRDS ( url ( ....) ) ` to read data stored on the internet instead of in your project.\n\n``` \nmydata <- readRDS ( \"mydata_file.RDS\")\nload ( \"mydata_file.Rda\")\n\n```\n\n#### Reading text (csv) files \n\nUse `read_csv()`, `read_tsv()`, `read_delimited()` and various fixed file formats. Match the type of your file with the proper function. These require that the tidyverse or `readr` libraries are already loaded. \n\n#### Reading Excel files\n\n\n\n``` \nlibrary (readxl)          # put this with the rest of your libraries.\nmydata <- read_excel(\"mydata_file.xlsx\", \n                      sheet = \"sheet_name\")  \n```\n\nThere is no `url()` option for reading Excel files. They must be stored in your project.  One approach is to download the file in your code: \n\n```\ndownload.file ( \"https://address-of-file.xlsx\", \"myfilename.xlsx\")\nmydata <- read_excel (\"myfilename.xlsx\")\n```\n\n\n#### Import options\n\nThere are options in most of the importing functions that tell you how to treat each column and let you rename at the same time. One approach is : \n\n``` \nread_csv ( \"mydata_file.csv\", \n           coltypes = col(.default = \"c\")\n           )\n           \n```\n\nTo keep everything as text, which you can convert later. \n\n\n## Filtering\n\n1.  One condition that's a number :\n\n```\n  filter ( amount > 1000 )\n```\n\n2.  A number between two values\n\n```\n  filter ( between ( amount, 0, 1000))\n```\n\n3.  An exact phrase or word\n\n```\n  filter ( project_county == \"MARICOPA\")\n```\n\n4.  One of several possible entries in one column (exactly)\n\n```\n    filter ( project_county %in% c(\"MARICOPA\", \"PIMA\", \"PINAL\" ))\n```\n5.  Everything except missing values\n\n```\n    filter ( ! is.na (project_county) )\n```\n\n5.  Between two dates . Be sure it's really a date in the data by glimpsing your data frame. If not, turn it into a date first.\n\n```\n    filter ( approval_date >= \"2021-01-24\" & \n           approval_date <= \"2021-01-31\")\n```\n6.  Phrases, words or letters at the beginning of a column\n\n```\n    filter ( str_like (borrower_type , \"Non-Profit%\"))\n```\n\n7.  Phrases, letters or words at the end of a column\n\n```\n    filter ( str_like  (borrower_type, \"Corporation%\"))\n```\n\nAll of these examples can be used in a `mutate` statement to create flags or new values if the conditions are met.  \n\n## Aggregate (count, sum rows by category)\n\n1.  Counting (How many?)\n\n```\n    group_by (project_county) |>\n    summarize (loans = n() )  |>\n    arrange ( desc ( loans ))\n```\n\nMake sure you don't name the new column containing the count the same thing as a group_by() column.\n\n2. Shortcut for counting:\n\n```\n     count( project_county, sort=TRUE, name=\"loans\")\n```\n\n\n3.  Counting unique entries\n\nSometimes you want to know how many items of a type, not how many rows, are included in a category.\n\n```\n        group_by ( project_county) |>\n        summarize ( number_of_loans = n(), \n                    number_of_industries = n_distinct ( naics_code )\n                    )\n```\n\n\n4.  Summing (how much?)\n\n```\n    group_by (project_county) |>\n    summarize ( total_amount = sum (amount, na.rm=T))\n```\n\n5. Shortcut for summing:\n\n```\n    count ( project_county, weight=amount, name=\"total_amount\")\n```\n\n## Recoding categories\n\nYou'll often want fewer categories, or numbers in categories, that you want to use instead of the original values. This is done in a mutate statement. Don't forget to save the output to a new data frame (<-), or you won't have access to it later on. \n\n\n1.  Create yes-no categories . This is really \"Yes\", \"No\" or NA, where there is an NA to begin with.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n    mutate ( corp_yn = if_else  \n                      (str_detect (borrower_type, \n                                   \"Corporation\"), \n                       \"Yes\", \n                       \"No\")\n       )\n```\n:::\n\n\n2. Recode into more than two categories using `case_when()`\n\nThis example introduces `str_detect()`, which uses regular expressions. We'll go over that later in the book. \n\n```\n  mutate (  new_business_type = \n                case_when (  str_like(business_type, \"%non_profit%\") ~ \"Non-profit\",    #1st category\n\n                             business_type %in% \n                               c(\"Independent Contractors\", \n                                \"Sole Proprietorship\", \n                                \"Self-Employed Individuals\", \n                                  \"Single Member LLC\")              ~ \"Individual\",    # 2nd category\n                             \n                             business_type == \"Tribal Concerns\"     ~ \"Tribal concerns\",    #3rd category\n                             \n                             str_detect (business_type, \"LLC|Company|Corporation|Partnership\") ~ \"Companies\",  #4th category\n                             \n                             TRUE ~ \"Other\")         #catchall 5th category\n            )\n```\n\n3. Recode numbers into categories\n\nIt's often useful to give them numeric codes in front so they sort properly:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n        mutate ( new_type = \n                 case_when  (\n                    amount <= 1000 ~ \"00-Very low\", \n                    amount <= 10000  ~ \"01-Low\", \n                    amount <= 100000 ~ \"03-Medium\", \n                    amount > 100000 ~ \"04-High\")\n              )\n```\n:::\n\n\nThis works because the first one that it finds will be used, so a value of exactly 1,000 would be \"Very low\", but a value of 1,001 would be \"Low\".\n\n\n## Working with grouped data for subtotals, changes, percents\n\n1.  Percent of total by group\n\n```\n  group_by ( project_county, sector_desc ) |>\n  summarize ( loans = n() , .groups=\"drop_last\") |>\n  mutate ( pct_in_county = loans / sum(loans))\n```\n\n2. Display results as in spreadsheet form\n\nTo see the items across the top, use `pivot_wider`. \n\n```\n  group_by ( project_county, new_type) |>\n  summarize ( loan_count = n() ) |>\n  pivot_wider ( names_from = new_type, \n                id_cols = c( project_county), \n                values_from = loan_count)\n```\n\nYou can add an argument after `values_from` if you know that any missing values are zero, by using `values_fill=0`\n\nYou usually only choose one column to show down the side, one column to spread across the top, and one column to display the value. \n\n2.  Complex example: Get the change by year within each county.\n\n      annual_ppp <- \n        mutate  ( approve_year = year (approval_date ) ) |>\n        group_by ( project_county, approve_year) |>\n        summarize ( loans = n() , \n                    amount = sum( amount, na.rm=T), \n                    .groups=\"drop_last\") \n                    \nNext, compare them within groups. New functions introduced: `complete()`, which fills in missing information in a sequence. For example, if there were missing years by county, it would create a row to fill it in. `lag()` refers to the previous item in a group. First, make a new, summarized data frame with just the columns you nee\n\n                    \n        complete ( project_county, approve_year, \n                  fill= list (amount=0, loans =0) )|>\n        mutate ( change_loans = loans - lag(loans), \n                 pct_change_loans = change_loans / lag(loans) * 100) \n\n3.  Pick out the last item in a group, with all of its columns. New verb introduced : `slice_tail()` . This is particularly useful for chronological events, such as the last thing that happened in a court case, or the most recent complaint against a police officer. This example isn't a great one, but it gets you the name and other details of the most recent loan for each lender\n\n        arrange ( lender, date_approved) |>\n        group_by ( lender) |>\n        slice_tail(n=1)\n\nNOTE: Don't use `slice_max()`, because it will give you back multiple rows in the event of ties. \n\n\n## Joining tables\n\nNew options in the `dplyr` library that contains the `join` verb let us use the same operators in joining that you use in filtering: `==`, `<=`, etc. Usually you will use the \"==\" operator.  Requires dplyr 1.1, which was released in February 2023. \n\n```\nppp_orig |> \n  select ( borrower_name, amount, naics_code) |> \n  inner_join ( naics_codes, \n               join_by (naics_code == naics_code) \n  )\n```\n\n## Quarto document tips\n\n### YAML (front matter) {-}\n\nThe YAML is very picky about exact casing, spacing and other details. If you try to render and you get a `YAML error`, it is likely at the top. \n\n\nTypical YAML front matter that goes within the three dashes beginning on the very first line:\n\n```yaml\n\ntitle: \"Name of document\"\nauthor: \"Your name\"\noutput: \n  html: \n    theme: cosmo\n    code-tools: true\n    embed-resources: true\n    toc: true\nexecute: \n   warning: true\n   error: true\n```\n  \n  \n\n### Code chunk options {-}\n\nThese must be the very first rows in your code chunk, and must start in the first position, with spacing as shown. Use `#| label: setup` in the first code chunk to run it automatically every time you start up R. \n\n\n::: {.cell}\n\n:::\n\n\n\n### Nothing runs; everything is gray {-}\n\nYou probably erased the last three back-ticks at the end of the code chunk. You may need to restart R to get it re-set. \n\n\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<link href=\"site_libs/pagedtable-1.1/css/pagedtable.css\" rel=\"stylesheet\" />\n<script src=\"site_libs/pagedtable-1.1/js/pagedtable.js\"></script>\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}